# version 300 es
  // generated by OpenDarkroom/tools/nlmeans
  // impliments fast nlmeans filter in glsl
  uniform sampler2D texSampler;
  uniform highp float amount;
  uniform ivec2 size;
  uniform bool vnoise;
  uniform bool vweights;
  uniform int selweight;
  uniform highp float mag;
  in highp vec2 textureCoord;
  out highp vec4 fragmentColor;
  const highp vec3 dotsums = vec3(0.33333333333,0.33333333333,0.33333333333);
  highp vec4 csample(ivec2 s) {return texelFetch(texSampler, ivec2(clamp(s.x, 0, size.x-1), clamp(s.y, 0, size.y-1)), 0);}
  highp vec3 rgbsample(ivec2 s) {return texelFetch(texSampler, ivec2(clamp(s.x, 0, size.x-1), clamp(s.y, 0, size.y-1)), 0).rgb;}
  void sampleKernal(ivec2 center, inout vec3 [9]src){
 src[0] = rgbsample(center+ivec2(-1,1));
 src[1] = rgbsample(center+ivec2(0,1));
 src[2] = rgbsample(center+ivec2(1,1));
 src[3] = rgbsample(center+ivec2(-1,0));
 src[4] = rgbsample(center+ivec2(0,0));
 src[5] = rgbsample(center+ivec2(1,0));
 src[6] = rgbsample(center+ivec2(-1,-1));
 src[7] = rgbsample(center+ivec2(0,-1));
 src[8] = rgbsample(center+ivec2(1,-1));
}
highp float placeAndCompare(ivec2 center, vec3 [9]compare, inout vec3 insample){
  highp float acc = 0.001;
  highp vec3 diff;
  ( diff = rgbsample(center+ivec2(-1,1)) -compare[0]) * 0.13092592000164083;
  acc += dot(diff*diff, dotsums);
  ( diff = rgbsample(center+ivec2(0,1)) -compare[1]) * 0.09998502931995472;
  acc += dot(diff*diff, dotsums);
  ( diff = rgbsample(center+ivec2(1,1)) -compare[2]) * 0.13092592000164083;
  acc += dot(diff*diff, dotsums);
  ( diff = rgbsample(center+ivec2(-1,0)) -compare[3]) * 0.09998502931995472;
  acc += dot(diff*diff, dotsums);
  ( diff = rgbsample(center+ivec2(0,0)) -compare[4]) * 0.07635620271361789;
  acc += dot(diff*diff, dotsums);
  ( diff = rgbsample(center+ivec2(1,0)) -compare[5]) * 0.09998502931995472;
  acc += dot(diff*diff, dotsums);
  ( diff = rgbsample(center+ivec2(-1,-1)) -compare[6]) * 0.13092592000164083;
  acc += dot(diff*diff, dotsums);
  ( diff = rgbsample(center+ivec2(0,-1)) -compare[7]) * 0.09998502931995472;
  acc += dot(diff*diff, dotsums);
  ( diff = rgbsample(center+ivec2(1,-1)) -compare[8]) * 0.13092592000164083;
  acc += dot(diff*diff, dotsums);
  insample = rgbsample(center);
  return acc/9.0;
}
void main(void){

    highp ivec2 p = ivec2(int(textureCoord.x * float(size.x)), int(textureCoord.y * float(size.y)));
    highp vec4 color = csample(p);
    highp float [9]finalKernalWeights;
    highp vec3 [9]finalKernalSamples;
    highp vec3 [9]center;

    sampleKernal(p+ivec2( 0, 0), center);
   finalKernalWeights[0] = placeAndCompare(p+ivec2(-1, 1), center, finalKernalSamples[0]);
 finalKernalWeights[1] = placeAndCompare(p+ivec2(0, 1), center, finalKernalSamples[1]);
 finalKernalWeights[2] = placeAndCompare(p+ivec2(1, 1), center, finalKernalSamples[2]);
 finalKernalWeights[3] = placeAndCompare(p+ivec2(-1, 0), center, finalKernalSamples[3]);
 finalKernalWeights[4] = 0.01;
 finalKernalSamples[4] = color.rgb;
 finalKernalWeights[5] = placeAndCompare(p+ivec2(1, 0), center, finalKernalSamples[5]);
 finalKernalWeights[6] = placeAndCompare(p+ivec2(-1, -1), center, finalKernalSamples[6]);
 finalKernalWeights[7] = placeAndCompare(p+ivec2(0, -1), center, finalKernalSamples[7]);
 finalKernalWeights[8] = placeAndCompare(p+ivec2(1, -1), center, finalKernalSamples[8]);
 highp float maxweight = 0.0;
 if (finalKernalWeights[0] > maxweight) {maxweight = finalKernalWeights[0];}
 if (finalKernalWeights[1] > maxweight) {maxweight = finalKernalWeights[1];}
 if (finalKernalWeights[2] > maxweight) {maxweight = finalKernalWeights[2];}
 if (finalKernalWeights[3] > maxweight) {maxweight = finalKernalWeights[3];}
 if (finalKernalWeights[4] > maxweight) {maxweight = finalKernalWeights[4];}
 if (finalKernalWeights[5] > maxweight) {maxweight = finalKernalWeights[5];}
 if (finalKernalWeights[6] > maxweight) {maxweight = finalKernalWeights[6];}
 if (finalKernalWeights[7] > maxweight) {maxweight = finalKernalWeights[7];}
 if (finalKernalWeights[8] > maxweight) {maxweight = finalKernalWeights[8];}
 finalKernalWeights[0] = maxweight-finalKernalWeights[0];
 finalKernalWeights[1] = maxweight-finalKernalWeights[1];
 finalKernalWeights[2] = maxweight-finalKernalWeights[2];
 finalKernalWeights[3] = maxweight-finalKernalWeights[3];
 finalKernalWeights[4] = maxweight-finalKernalWeights[4];
 finalKernalWeights[5] = maxweight-finalKernalWeights[5];
 finalKernalWeights[6] = maxweight-finalKernalWeights[6];
 finalKernalWeights[7] = maxweight-finalKernalWeights[7];
 finalKernalWeights[8] = maxweight-finalKernalWeights[8];
 highp float weightsum = finalKernalWeights[0]+finalKernalWeights[1]+finalKernalWeights[2]+finalKernalWeights[3]+finalKernalWeights[4]+finalKernalWeights[5]+finalKernalWeights[6]+finalKernalWeights[7]+finalKernalWeights[8];
 highp vec3 acc = vec3(0);
 acc += (finalKernalWeights[0]/weightsum)*finalKernalSamples[0];
 acc += (finalKernalWeights[1]/weightsum)*finalKernalSamples[1];
 acc += (finalKernalWeights[2]/weightsum)*finalKernalSamples[2];
 acc += (finalKernalWeights[3]/weightsum)*finalKernalSamples[3];
 acc += (finalKernalWeights[4]/weightsum)*finalKernalSamples[4];
 acc += (finalKernalWeights[5]/weightsum)*finalKernalSamples[5];
 acc += (finalKernalWeights[6]/weightsum)*finalKernalSamples[6];
 acc += (finalKernalWeights[7]/weightsum)*finalKernalSamples[7];
 acc += (finalKernalWeights[8]/weightsum)*finalKernalSamples[8];

    fragmentColor.rgb = acc;
    fragmentColor.a  = 1.0;
  }
