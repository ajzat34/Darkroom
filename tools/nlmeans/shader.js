// genorate nlmeans frag shaders
module.exports=function(kn,sn){
  // kernal area
  // var kn = 1 // radius of patches in pixels
  var ks = (kn*2)+1 // dimentions of patches in pixels
  var ksq = ks*ks // area of patches in pixels

  // search area
  // var sn = 2 // radius of search area in pixels
  var ss = (sn*2)+1// dimentions of search area in pixels
  var ssq = ss*ss // area of search area in pixels

  var sscenter = (ss*sn)+(sn)

  var kv = []
  for (var y = kn; y>=-kn; y--){
    for (var x = -kn; x<=kn; x++){
      kv.push({x: x, y: y})
    }
  }

  var sv = []
  for (var y = sn; y>=-sn; y--){
    for (var x = -sn; x<=sn; x++){
      sv.push({x: x, y: y})
    }
  }

  var gaussianWeights = gaussianNDist2D(ks, kn+1)

  var header =
  `# version 300 es
  // generated by OpenDarkroom/tools/nlmeans
  // impliments fast nlmeans filter in glsl
  uniform sampler2D texSampler;
  uniform highp float amount;
  uniform ivec2 size;
  uniform bool vnoise;
  uniform bool vweights;
  uniform int selweight;
  uniform highp float mag;
  in highp vec2 textureCoord;
  out highp vec4 fragmentColor;
  const highp vec3 dotsums = vec3(0.33333333333,0.33333333333,0.33333333333);
  highp vec4 csample(ivec2 s) {return texelFetch(texSampler, ivec2(clamp(s.x, 0, size.x-1), clamp(s.y, 0, size.y-1)), 0);}
  highp vec3 rgbsample(ivec2 s) {return texelFetch(texSampler, ivec2(clamp(s.x, 0, size.x-1), clamp(s.y, 0, size.y-1)), 0).rgb;}
  `

  var genKsample = `void sampleKernal(ivec2 center, inout vec3 [${ksq}]src)`
  genKsample += '{\n'
  kv.forEach((sample, i) => {
    genKsample += ` src[${i}] = rgbsample(center+ivec2(${sample.x},${sample.y}));\n`
  })
  genKsample += '}\n'

  var genPlaceCompare = `highp float placeAndCompare(ivec2 center, vec3 [${ksq}]compare, inout vec3 insample)`
  genPlaceCompare += '{\n'
  genPlaceCompare += `  highp float acc = 0.001;\n`
  genPlaceCompare += `  highp vec3 diff;\n`
  kv.forEach((sample, i) => {
    genPlaceCompare += `  ( diff = rgbsample(center+ivec2(${sample.x},${sample.y})) -compare[${i}]);\n`
    genPlaceCompare += `  acc += dot(diff*diff, dotsums);\n`
  })
  genPlaceCompare += `  insample = rgbsample(center);\n`
  genPlaceCompare += `  return acc/${ks*ks}.0;\n`
  genPlaceCompare += '}\n'

  var main = `void main(void)`
  main += '{\n'
  main += `
    highp ivec2 p = ivec2(int(textureCoord.x * float(size.x)), int(textureCoord.y * float(size.y)));
    highp vec4 color = csample(p);
    highp float [${ssq}]finalKernalWeights;
    highp vec3 [${ssq}]finalKernalSamples;
    highp vec3 [${ksq}]center;

    sampleKernal(p+ivec2( 0, 0), center);
  `
  sv.forEach((sample, i) => {
    if (i === sscenter) {
      main += ` finalKernalWeights[${i}] = 0.01;\n`
      main += ` finalKernalSamples[${i}] = color.rgb;\n`
    } else {
      main += ` finalKernalWeights[${i}] = placeAndCompare(p+ivec2(${sample.x}, ${sample.y}), center, finalKernalSamples[${i}]);\n`
    }
  })
  main += ` highp float maxweight = 0.0;\n`
  sv.forEach((sample, i) => {
    main += ` if (finalKernalWeights[${i}] > maxweight) {maxweight = finalKernalWeights[${i}];}\n`
  })

  sv.forEach((sample, i) => {
    main += ` finalKernalWeights[${i}] = maxweight-finalKernalWeights[${i}];\n`
  })

  var sums = []
  sv.forEach((sample, i) => {
    sums.push(`finalKernalWeights[${i}]`)
  })
  main += ` highp float weightsum = ${sums.join('+')};\n`

  main += ` highp vec3 acc = vec3(0);\n`
  sv.forEach((sample, i) => {
    main += ` acc += (finalKernalWeights[${i}]/weightsum)*finalKernalSamples[${i}];\n`
  })
  main += `
    fragmentColor.rgb = acc;
    fragmentColor.a  = 1.0;
  `
  main += '}\n'

  final = ''
  final += header
  final += genKsample
  final += genPlaceCompare
  final += main

  console.log(kn, sn, ks, ss)

  return final
}
